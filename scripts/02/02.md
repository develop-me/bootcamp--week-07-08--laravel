# Day 2: Afternoon

## TDD

- Write our tests *first*
- Write failing test first, then write code to make it work. Then write next test.
- Red, Green, Refactor
    - Red: write the test - what does it need to do?
    - Green: smallest bit of code to get it working - how are we going to do it?
    - Refactor: tidy up code
- Refactoring: changing the code without changing what it does
- Errors are red, but we want to get a *failure* before aiming for green
- If we're doing it properly, should never write a new line of code without first having a test for it
- Guarantees that if we make changes and all the tests pass it definitely still does what we think
- Freedom to make changes without worrying about breaking things
- If you find a bug, add a new test

### Roman Numerals

- new `App\RomanNumeral` class
- `aritsan make:test RomanNumeralTest --unit`
- Add setup:

    ```php
    public function setUp() : void
    {
        $this->rn = new RomanNumeral();
    }
    ```

- Add first test `test1`

    ```php
    public function test1()
    {
        $this->assertSame("I", $fizzbuzz->forNumber(1));
    }
    ```
- **RUN TESTS AT EVERY STAGE**
- Run test: red **error** - method doesn't exist
- Add empty `forNumber` method to `RomanNumeral`
- Run test: red **failure** - ready to go
- Get to green:
    - Don't accept a parameter
    - Just return `I`
    - Add `string` return type
    - *smallest* bit of code to get it working
- *Run tests*
- Might seem silly, but it's all that was necessary to pass the test. If we want more functionality we need more tests
- Add `test2()` for `2` - run tests, fix, run tests
    - Accept the value passed (add `int` type)
    - Just return `II` if `2`
    - No obvious refactoring
- Add `test3()` for `3` - run tests, fix, run tests
    - Just return `III` if `3`
- **Refactor** using `str_repeat("I", $n)`
- Add `test4` for `4` - run tests, fix, run tests
    - Back to an `if` statement
- Add `test5` for `5` - run tests, fix, run tests
    - Another `if` statement
- Too many `if`s. Can **refactor** using a dictionary:

    ```php
    private $dictionary = [
        5 => "V",
        4 => "IV",
    ];
    ```

    ```php
    foreach ($this->dictionary as $value => $numeral) {
        if ($number === $value) {
            return $numeral;
        }
    }
    ```

    Order is important!

- Add `test6` for `6` - run tests, fix, run tests
    - Just add to dictionary for now
- Add `test7` for `7` - run tests, fix, run tests
    - Add to dictionary again
- Looks like there's a pattern: 6 and 7 are just 5 + 1 and 5 + 2
- But let's keep going, two might just be a coincidence
- Add `test8` for `8` - run tests, fix, run tests
    - Add to dictionary again
- **Refactor**: *definitely* a pattern now: 8 is 5 + 3
    - Rather than returning in dictionary loop, build up string and subtract the value
    - Then concatenate with `str_repeat` at end
- Add `test9` for `9` - run tests, fix, run tests
    - That's not part of the pattern, so `IX` into the dictionary
- Add `test10` for `10` - run tests, fix, run tests
    - Also not part of the pattern, so `X` into the dictionary
- Add `test11` for `11` - run tests
    - Should work for free!
- Add `test14` for `14` - run tests, fix, run tests
    - Feels predictable
    - But won't work, so add `XIV` to dictionary
- Add `test15` for `15` - run tests, fix, run tests
    - Again, feels predictable
    - But won't work, so add `XV` to dictionary
- Add `test16` for `16` - run tests, fix, run tests
    - Again, feels predictable
    - But won't work, so add `XVI` to dictionary
- **Refactor**: Definitely a pattern again.
    - If we keep running the loop until we're out of values and concatenate as we go, we should get the last two for free:

    ```php
    $result = "";

    foreach ($this->dictionary as $value => $numeral) {
        if ($number === $value) {
            $result .= $numeral;
            $number -= $value;
        }
    }

    return str_repeat("I", $number);
    ```

- **Refactor again!**: if we add `I` to the dictionary we don't need the `str_repeat` at the end, just return `$number`!

- Add `test19` for `19` - run tests
    - Works for free
- Add `test20` for `20` - run tests
    - Works for free
- Add `test40` for `40` - run tests, fix, run tests
    - Need to add `XL` to dictionary
- Add `test49` for `49` - run tests
    - Works for free
- Add `test50` for `50` - run tests, fix, run tests
    - Need to add `L` to dictionary
- Add `test90` for `90` - run tests, fix, run tests
    - Need to add `XC` to dictionary
- Add `test99` for `99` - run tests
    - Works for free
- Add `test100` for `100` - run tests, fix, run tests
    - Need to add `C` to dictionary
- Add `test400` for `400` - run tests, fix, run tests
    - Need to add `CD` to dictionary
- Add `test499` for `499` - run tests
    - Works for free
- Add `test900` for `900` - run tests, fix, run tests
    - Need to add `CM` to dictionary
- Add `test999` for `999` - run tests
    - Works for free
- Add `test1000` for `1000` - run tests, fix, run tests
    - Need to add `M` to dictionary
- Add `test3994` for `3994` - run tests
    - Should work!
- Ask students to pick a number to test between 5000 and 10000
    - Add a test
    - Show it works!

### Git Hooks

- Hooks let us intercept bit of life-cycle
- Live in `.git/hooks` - not part of the repo
- `pre-commit`: Non-zero exit code won't let us commit
- Create `pre-commit` hook

    ```bash
    #!/bin/bash

    vendor/bin/phpunit --testsuite Unit
    ```

- `chmod +x .git/hooks/pre-commit`
- Mention `git bisect`
