We've already seen that it can be useful to write tests for our code.
\\

But what if we wrote the tests \textit{first}? This is the key idea behind \textbf{Test Driven Development}.
\\

Rather than writing a piece of functionality and then testing it when we think it works, TDD says we should first write a test that fails and then write the code that will make the test work. If you're doing TDD properly you should never write a piece of code without having written a test for it first.

\section{Red, Green, Refactor}

When writing test-driven code you enter the ``Red, Green, Refactor'' loop.

\begin{itemize}
    \item \textbf{Red}: write a \textit{failing} test - and check that it fails
    \item \textbf{Green}: write the \textit{smallest amount of code} that you can to pass the test
    \item \textbf{Refactor}: can you improve the code without breaking any of the tests
\end{itemize}

Remember, ``refactoring'' means: rewriting a piece of code without changing what it does.

\begin{infobox}{Failures vs Errors}
    Both failures \textit{and} errors result in \textbf{red} - code that's not doing what we want it to. However, we shouldn't start aiming for green until we have a \textbf{red} \textit{failure}. So sort any errors first (syntax errors, missing files).
\end{infobox}


\section{Why?}

This might seem like a crazy way to write code, but it forces you to think about what you're actually doing. The \textbf{red} stage make you think ``What does this code \textit{actually} need to do?''. The \textbf{green} phase lets you think about how to get it working in the simplest possible way. The \textbf{refactor} phase lets you improve your code without worrying about breaking anything.
\\

If you use TDD for \textit{every line of code in your application}, then you have the freedom to change whatever you like with the guarantee that \textit{if all the tests still pass, it definitely still does what it did before}. This can be incredibly liberating!
\\

Initially, you probably think that writing code this way will be much slower. And to start with it will be. But if you can get into the right mindset, you may find that it allows you to reason about you code in a much more straightforward manner. And when it comes to making changes later – which is what you'll spend most of your time doing – you'll find you save a huge amount of time and mental effort.

\section{FizzBuzz}

Let's write FizzBuzz using TDD. We'll use TDD for more practical purposes later.
\\

We'll need two classes, \texttt{FizzBuzz} and \texttt{FizzBuzzTest}.
\\

Put the following in \texttt{app/FizzBuzz.php}:

\begin{minted}{php}
    namespace App;

    class FizzBuzz
    {
        public function forNumber()
        {

        }
    }
\end{minted}

Now, create a test:

\begin{minted}{bash}
    artisan make:test FizzBuzzTest --unit
\end{minted}

And update that file to look like this:

\begin{minted}{php}
    namespace Tests\Unit;

    use PHPUnit\Framework\TestCase;

    class FizzBuzzTest extends TestCase
    {
        public function testForNumber()
        {

        }
    }
\end{minted}

Now run your tests. Seriously:

\begin{minted}{bash}
    vendor/bin/phpunit --filter FizzBuzz
\end{minted}

We've limited testing just to \texttt{FizzBuzz} so we don't get any noise. You should see that the tests pass (because there aren't any), but we get a message telling us we didn't perform any assertions.
\\

It's important to run your tests even when you know they'll fail, because sometimes they \textit{won't}, which might mean you've set your tests up wrong!
\\

1)

```php
public function test1()
{
    $this->assertSame("I", $this->rn->toNumeral(1));
}
```

2)

```php
public function test2()
{
    $this->assertSame("II", $this->rn->toNumeral(2));
}
```

3)

```php
public function test3()
{
    $this->assertSame("III", $this->rn->toNumeral(3));
}
```

**Hint**: Now might be a good chance to do a bit of refactoring. Maybe look at [`str_repeat`](http://www.php.net/manual/en/function.str-repeat.php)


4)

```php
public function test4()
{
    $this->assertSame("IV", $this->rn->toNumeral(4));
}
```

5)

```php
public function test5()
{
    $this->assertSame("V", $this->rn->toNumeral(5));
}
```

6)

```php
public function test6()
{
    $this->assertSame("VI", $this->rn->toNumeral(6));
}
```

**Hint**: 6 is 5 + 1

7)

```php
public function test7()
{
    $this->assertSame("VII", $this->rn->toNumeral(7));
}
```

**Hint**: 7 is 5 + 2

8)

```php
public function test8()
{
    $this->assertSame("VIII", $this->rn->toNumeral(8));
}
```

**Hint**: 8 is 5 + 3

9)

```php
public function test9()
{
    $this->assertSame("IX", $this->rn->toNumeral(9));
}
```

10)

```php
public function test10()
{
    $this->assertSame("X", $this->rn->toNumeral(10));
}
```

11)

```php
public function test10()
{
    $this->assertSame("XIV", $this->rn->toNumeral(14));
}
```

**Hint**: 14 is 10 + 4

12)

```php
public function test20()
{
    $this->assertSame("XX", $this->rn->toNumeral(20));
}
```

**Hint**: 20 is 10 * 2

13)

```php
public function test40()
{
    $this->assertSame("XL", $this->rn->toNumeral(40));
}
```

14)

```php
public function test49()
{
    $this->assertSame("XLIX", $this->rn->toNumeral(49));
}
```

**Hint**: `IX` seems familiar


15)

```php
public function test50()
{
    $this->assertSame("L", $this->rn->toNumeral(50));
}
```

16)

```php
public function test90()
{
    $this->assertSame("XC", $this->rn->toNumeral(90));
}
```

15)

```php
public function test99()
{
    $this->assertSame("XCIX", $this->rn->toNumeral(99));
}
```

**Hint**: `IX` again...

16)

```php
public function test100()
{
    $this->assertSame("C", $this->rn->toNumeral(100));
}
```

17)

```php
public function test400()
{
    $this->assertSame("CD", $this->rn->toNumeral(400));
}
```

18)

```php
public function test499()
{
    $this->assertSame("CDXCIX", $this->rn->toNumeral(499));
}
```

**Hint**: 499 is 400 + 90 + 9

19)

```php
public function test500()
{
    $this->assertSame("D", $this->rn->toNumeral(500));
}
```

20)

```php
public function test900()
{
    $this->assertSame("CM", $this->rn->toNumeral(900));
}
```

21)

```php
public function test999()
{
    $this->assertSame("CMXCIX", $this->rn->toNumeral(999));
}
```

22)

```php
public function test1000()
{
    $this->assertSame("M", $this->rn->toNumeral(1000));
}
```

23)

```php
public function test3994()
{
    $this->assertSame("MMMCMXCIV", $this->rn->toNumeral(3994));
}
```

24) If you've got 23 conditionals, now is the time to refactor!

Right, let's get our first fail. In \texttt{FizzBuzzTest}:

\begin{minted}{php}
    public function testForNumber()
    {
        $fizzbuzz = new FizzBuzz();
        $this->assertSame("1", $fizzbuzz->forNumber(1));
    }
\end{minted}

Now, \textbf{run your tests}. You should see that you get a failure saying \texttt{Failed asserting that null is identical to \textquotesingle{}1\textquotesingle{}}. This is \textit{good}, according to TDD we can't start writing in FizzBuzz \textit{until} we have a failing test. Start with \textbf{red}.
\\

Let's get our test passing. In \texttt{FizzBuzz}:

\begin{minted}{php}
    public function forNumber(int $number) : string
    {
        return "1";
    }
\end{minted}

\textbf{Run your tests}. Our first \textbf{green}!
\\

Now, you're thinking is probably a mixture of confusion and expletives. Of course they passed! But the method \textit{always} returns \texttt{"1"}.
\\

But, remember the rules of TDD: write the \textit{smallest amount of code} that you can to pass the test. And that's just what we did. Just remember, \textit{we're not finished yet}.
\\

We can't really refactor our code at the moment, it's about as simple as it can be. So let's get back to \textbf{red}. Add a new test:

\begin{minted}{php}
    $this->assertSame("2", $fizzbuzz->forNumber(2));
\end{minted}

\textbf{Run your tests}. Totes \textbf{red}.
\\

Let's fix that:

\begin{minted}{php}
    public function forNumber(int $number) : string
    {
        // wrap what's passed in as a string
        return "{$number}";
    }
\end{minted}

\textbf{Run your tests}. \textbf{Green}!
\\

It's important that we didn't write it like this initially. We should only write things that make a test pass and we didn't need to write it this way until we added the second test. If you skip stages you're also \textit{skipping tests} which means your code might not be as tested as you think.
\\

Again, no refactoring necessary. So let's get back to \textbf{red}:

\begin{minted}{php}
    $this->assertSame("Fizz", $fizzbuzz->forNumber(3));
\end{minted}

\textbf{Run your tests}. \textbf{Red}. And let's get it working:

\begin{minted}{php}
    public function forNumber(int $number) : string
    {
        if ($number === 3) {
            return "Fizz";
        }

        return "{$number}";
    }
\end{minted}

\textbf{Run your tests}. \textbf{Green.} You'll notice it's slowly starting to resemble the answer to FizzBuzz that you're familiar with, but TDD is forcing us to do it bit by bit.
\\

We could maybe refactor at this point (maybe use a ternary?), but it's best not to refactor \textit{too} soon, so let's leave it as is for now.
\\

Next test:

\begin{minted}{php}
    $this->assertSame("4", $fizzbuzz->forNumber(4));
\end{minted}

\textbf{Run your tests}. \textbf{Green!} Didn't even have to do anything that time.
\\

Next test:

\begin{minted}{php}
    $this->assertSame("Buzz", $fizzbuzz->forNumber(5));
\end{minted}

\textbf{Run your tests}. \textbf{Red} again. Let's fix it:

\begin{minted}{php}
    public function forNumber(int $number) : string
    {
        if ($number === 3) {
            return "Fizz";
        }

        if ($number === 5) {
            return "Buzz";
        }

        return "{$number}";
    }
\end{minted}

\textbf{Run your tests}. Back to \textbf{green}.
\\

Next test:

\begin{minted}{php}
    $this->assertSame("Fizz", $fizzbuzz->forNumber(6));
\end{minted}

\textbf{Run your tests}. \textbf{Red}.
\\

Again, notice how TDD is forcing us to think about what we want to happen at every stage.
\\

Let's get it working. Update the first \texttt{if} statement to use \texttt{\%}:

\begin{minted}{php}
    if ($number % 3 === 0) {
        return "Fizz";
    }
\end{minted}

\textbf{Run your tests}. \textbf{Green}. Don't be tempted to do the same for \texttt{5} just yet: you've not written a test for it.
\\

We don't need to test every single possible value, just the ones we're interested in. So let's skip to \texttt{10}.

\begin{minted}{php}
    $this->assertSame("Buzz", $fizzbuzz->forNumber(10));
\end{minted}

\textbf{Run your tests}. Here's the \textbf{red} you were looking for. Now we can fix it:

\begin{minted}{php}
    if ($number % 5 === 0) {
        return "Buzz";
    }
\end{minted}

\textbf{Run your tests}. \textbf{Green} again. Now let's add our final test case:

\begin{minted}{php}
    $this->assertSame("FizzBuzz", $fizzbuzz->forNumber(15));
\end{minted}

\textbf{Run your tests}. \textbf{Red} again.
\\

Let's go for the simplest solution to start with:

\begin{minted}{php}
    public function forNumber(int $number) : string
    {
        if ($number % 3 === 0 && $number % 5 === 0) {
            return "FizzBuzz";
        }

        // ...etc.
    }
\end{minted}

\textbf{Run your tests}. Back to \textbf{Green}.
\\

We've written all the tests, now we can \textbf{refactor}. But we can refactor \textit{without worrying about breaking things}: if the tests pass then it still does everything we want it to do.
\\

\hr

Some refactorings later:

\begin{minted}{php}
    public function forNumber(int $number) : string
    {
        $result = $number % 3 ? "" : "Fizz";
        $result .= $number % 5 ? "" : "Buzz";
        return $result ? $result : "{$number}";
    }
\end{minted}

The above is the result of many many refactorings. Some of them didn't work. But because I ran the tests \textit{every} time, I knew I'd made a mistake. I was free to try things and came up with a solution I genuinely wasn't expecting.


\section{Git Hooks}

Now that we're test-driven, we should be careful to never commit any code to Git \textit{if} any of our tests are failing.
\\

We can use \textbf{Git Hooks} to guarantee that we can't commit failing code. Hooks are custom bits of code that run at specific points in the Git life-cycle.
\\

We're interested in the \texttt{pre-commit} hook. If this bit of code returns an \textbf{error code} (any number except \texttt{0}) then Git won't allow the commit to run.
\\

When all of your PHPUnit tests succeed you get back a \texttt{0} exit code, but if any fail you'll get back a non-zero exit code. That means all we need to put in our hook is code that runs PHPUnit.
\\

Hooks live in the \texttt{.git/hooks} directory inside your project. So we need to create a file called \texttt{.git/hooks/pre-commit} and then put the following inside:

\begin{minted}{bash}
    #!/bin/bash

    vendor/bin/phpunit --testsuite Unit
\end{minted}

This is just the command that we've been running manually.
\\

We also need to give this file execution permissions, otherwise it can't be run:

\begin{minted}{bash}
    chmod +x .git/hooks/pre-commit
\end{minted}

Now, whenever you try to commit anything to Git the tests will run and if any of them fail the commit will fail. As long as you've used TDD, it's now not possible to commit broken code.

% git bisect?

\section{Additional Resources}

\begin{itemize}[leftmargin=*]
    \item \href{https://www.freecodecamp.org/news/test-driven-development-what-it-is-and-what-it-is-not-41fa6bca02a2/}{What is Test Driven Development?}
    \item \href{https://www.codecademy.com/articles/tdd-red-green-refactor}{Red, Green, Refactor}
    \item \href{https://www.sandimetz.com/99bottles}{99 Bottles of OOP}
    \item \href{https://git-scm.com/book/en/v2/Customizing-Git-Git-Hooks}{Git Hooks}
\end{itemize}
