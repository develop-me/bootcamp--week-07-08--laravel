We've already seen that it can be useful to write tests for our code.
\\

But what if we wrote the tests \textit{first}? This is the key idea behind \textbf{Test Driven Development}.
\\

Rather than writing a piece of functionality and then testing it when we think it works, TDD says we should first write a test that fails and then write the code that will make the test work. If you're doing TDD properly you should never write a piece of code without having written a test for it first.

\section{Red, Green, Refactor}

When writing test-driven code you enter the ``Red, Green, Refactor'' loop.

\begin{itemize}
    \item \textbf{Red}: write a \textit{failing} test - and check that it fails
    \item \textbf{Green}: write the \textit{smallest amount of code} that you can to pass the test
    \item \textbf{Refactor}: can you improve the code without breaking any of the tests
\end{itemize}

Remember, ``refactoring'' means: rewriting a piece of code without changing what it does.

\section{Why?}

This might seem like a crazy way to write code, but it forces you to think about what you're actually doing. The \textbf{red} stage make you think ``What does this code \textit{actually} need to do?''. The \textbf{green} phase lets you think about how to get it working in the simplest possible way. The \textbf{refactor} phase lets you improve your code without worrying about breaking anything.
\\

If you use TDD for \textit{every line of code in your application}, then you have the freedom to change whatever you like with the guarantee that \textit{if all the tests still pass, it definitely still does what it did before}. This can be incredibly liberating!
\\

Initially, you probably think that writing code this way will be much slower. And to start with it will be. But if you can get into the right mindset, you may find that it allows you to reason about you code in a much more straightforward manner. And when it comes to making changes later – which is what you'll spend most of your time doing – you'll find you save a huge amount of time and mental effort.

\section{Roman Numerals}

Let's write a class that converts an integer into a Roman Numeral using TDD.
\\

We'll need two classes, \texttt{RomanNumeral} and \texttt{RomanNumeralTest}.
\\

Put the following in \texttt{app/RomanNumeral.php}:

\begin{minted}{php}
    namespace App;

    class RomanNumeral
    {
    }
\end{minted}

Now, create a test:

\begin{minted}{bash}
    artisan make:test RomanNumeralTest --unit
\end{minted}

And update that file to look like this:

\begin{minted}{php}
    namespace Tests\Unit;

    use PHPUnit\Framework\TestCase;
    use App\RomanNumeral;

    class RomanNumeralTest extends TestCase
    {
        // store the RomanNumeral object
        private $rn;

        // create a new instance of the object
        // when the test starts
        public function setUp() : void
        {
            parent::setUp();
            $this->rn = new RomanNumeral();
        }
    }
\end{minted}

Right, let's get our first fail. In \texttt{RomanNumeralTest}:

\begin{minted}{php}
    public function test1()
    {
        $this->assertSame("I", $this->rn->forNumber(1));
    }
\end{minted}

Now run your tests:

\begin{minted}{bash}
    vendor/bin/phpunit --filter RomanNumeral
\end{minted}

We've limited testing just to \texttt{RomanNumeral} so we don't get any noise.
\\

You should see that we get an error saying \texttt{Call to undefined method \\ App\textbackslash{}RomanNumeral::forNumber()}. This is a \textbf{red}, but not the kind that we want.

\begin{infobox}{Failures vs Errors}
    Both failures \textit{and} errors result in \textbf{red} - code that's not doing what we want it to. However, we shouldn't start aiming for green until we have a \textbf{red} \textit{failure}. So sort any errors first (syntax errors, missing files).
\end{infobox}

Now add an empty method to \texttt{RomanNumeral}:

\begin{minted}{php}
    public function forNumber()
    {
    }
\end{minted}

Now, \textbf{run your tests} again. This time you should see that you get a failure saying \texttt{Failed asserting that null is identical to \textquotesingle{}I\textquotesingle{}}. This is \textit{good}, according to TDD we can't start trying to solve the problem in \texttt{RomanNumeral} \textit{until} we have a failing test. Start with \textbf{red}.
\\

Let's get our test passing. In \texttt{RomanNumeral}:

\begin{minted}{php}
    public function forNumber() : string
    {
        return "I";
    }
\end{minted}

\textbf{Run your tests}. Our first \textbf{green}!
\\

Now, you're probably thinking a mixture of confusion and expletives. Of course the test passed! But the method \textit{always} returns \texttt{"I"}.
\\

But, remember the rules of TDD: write the \textit{smallest amount of code} that you can to pass the test. And that's just what we did. Just remember, \textit{we're not finished yet}.
\\

We can't really refactor our code at the moment, it's about as simple as it can be. So let's get back to \textbf{red}. Add a new test:

\begin{minted}{php}
    public function test2()
    {
        $this->assertSame("II", $this->rn->forNumber(2));
    }
\end{minted}

\textbf{Run your tests}. Totes \textbf{red}.
\\

Let's fix that:

\begin{minted}{php}
    public function forNumber(int $number) : string
    {
        if ($number === 2) {
            return "II";
        }

        return "I";
    }
\end{minted}

\textbf{Run your tests}. \textbf{Green}!
\\

We could maybe refactor using a ternary, but let's leave it as is for now. Let's get back to \textbf{red}:

\begin{minted}{php}
    public function test3()
    {
        $this->assertSame("III", $this->rn->forNumber(3));
    }
\end{minted}

\textbf{Run your tests}. \textbf{Red}. And let's get it working:

\begin{minted}{php}
    public function forNumber(int $number) : string
    {
        if ($number === 3) {
            return "III";
        }

        if ($number === 2) {
            return "II";
        }

        return "I";
    }
\end{minted}

\textbf{Run your tests}. \textbf{Green.}
\\

Now you've maybe noticed a pattern? We're just repeating \texttt{I} the number of times stored in \texttt{\$number}. And PHP has a way to repeat a string a specified number of times, so let's refactor:

\begin{minted}{php}
    public function forNumber(int $number) : string
    {
        return str_repeat("I", $number);
    }
\end{minted}

\textbf{Run your tests}. Still \textbf{green}!
\\

We've simplified our code massively and all our tests are still passing, so we're guaranteed it still does everything it did before (and \textit{only} what it did before).
\\

It's important that we didn't write it like this initially. We should only write things that make a test pass and we shouldn't try to refactor too soon. It was only when a pattern became clear after the third test that it made sense to write it this way. If you skip stages you're also \textit{skipping tests} which means your code might not be as tested as you think.
\\


Next test:

\begin{minted}{php}
    public function test4()
    {
        $this->assertSame("IV", $this->rn->forNumber(4));
    }
\end{minted}

\textbf{Run your tests}. \textbf{Red} again.
\\

\texttt{IV} doesn't fit the previous pattern, so let's give it its own \texttt{if} statement:

\begin{minted}{php}
    public function forNumber(int $number) : string
    {
        if ($number === 4) {
            return "IV";
        }

        return str_repeat("I", $number);
    }
\end{minted}


Next test:

\begin{minted}{php}
    public function test5()
    {
        $this->assertSame("V", $this->rn->forNumber(5));
    }
\end{minted}

\textbf{Run your tests}. \textbf{Red} again. Let's fix it:

\begin{minted}{php}
    public function forNumber(int $number) : string
    {
        if ($number === 5) {
            return "V";
        }

        if ($number === 4) {
            return "IV";
        }

        return str_repeat("I", $number);
    }
\end{minted}

\textbf{Run your tests}. Back to \textbf{green}.
\\

But two \texttt{if} statements is starting to feel a bit much. In situations like this you could use a \texttt{switch} statement. \textit{Or} you could use a \textbf{dictionary}:

\begin{minted}{php}
    // values we want to check
    private $dictionary = [
        5 => "V",
        4 => "IV",
    ];

    public function forNumber(int $number) : string
    {
        // go through each value
        // if it's in the dictionary
        // return the corresponding value
        foreach ($this->dictionary as $value => $numeral) {
            if ($number === $value) {
                return $numeral;
            }
        }

        // otherwise just do as before
        return str_repeat("I", $number);
    }
\end{minted}

\textbf{Run your tests}. \textbf{Green}!
\\

A dictionary is just a key-value pair mapping one value to another, e.g. \texttt{IV} to \texttt{4}. If you ever find yourself writing a lot of \texttt{if} statements on the same value or needing to use a \texttt{switch} statement then you can often use a dictionary instead.
\\

Again, we've refactored our code and tested it. We can be sure that it does everything that it did before we made the changes.
\\

Let's keep going:

\begin{minted}{php}
    public function test6()
    {
        $this->assertSame("VI", $this->rn->forNumber(6));
    }
\end{minted}

\textbf{Test}. \textbf{Red}.
\\

Add it to the top of the dictionary (hopefully a pattern might begin to appear):

\begin{minted}{php}
    6 => "VI",
\end{minted}

\textbf{Test}. \textbf{Green}. Can't see a pattern, so move on.

\begin{minted}{php}
    public function test7()
    {
        $this->assertSame("VII", $this->rn->forNumber(7));
    }
\end{minted}

\textbf{Test}. \textbf{Red}.
\\

Add it to the top of the dictionary:

\begin{minted}{php}
    7 => "VII",
\end{minted}

\textbf{Test}. \textbf{Green}. An inkling of a pattern now, but let's make sure.

\begin{minted}{php}
    public function test8()
    {
        $this->assertSame("VIII", $this->rn->forNumber(8));
    }
\end{minted}

\textbf{Test}. \textbf{Red}.
\\

Add it to the top of the dictionary:

\begin{minted}{php}
    8 => "VIII",
\end{minted}

\textbf{Test}. \textbf{Green}.
\\

OK, there's definitely something going on here. The last three values are just \texttt{V} with \texttt{I} repeated. So \texttt{6} is just \texttt{V + I}, \texttt{7} is \texttt{V + II}, \&tc. And we've already got some code for adding the \texttt{I} bit. So let's refactor:

\begin{minted}{php}
    // back to just 5 and 4
    private $dictionary = [
        5 => "V",
        4 => "IV",
    ];

    public function forNumber(int $number) : string
    {
        // keep track of result
        $result = "";

        foreach ($this->dictionary as $value => $numeral) {
            // if $number is bigger than or equal to
            // the current dictionary value
            if ($number >= $value) {
                // concatenate the numeral onto the result
                $result .= $numeral;

                // subtract the value from number
                $number -= $value;
            }
        }

        // add I on as many times as necessary
        return $result . str_repeat("I", $number);
    }
\end{minted}

\textbf{Run your tests}. \textbf{Green} times are here again.
\\

We spotted a pattern, refactored, and then checked that everything still works by running our tests.
\\

Let's move on:

\begin{minted}{php}
    public function test9()
    {
        $this->assertSame("IX", $this->rn->forNumber(9));
    }
\end{minted}

\textbf{Run your tests}. \textbf{Red} as a red thing.
\\

This one doesn't fit the pattern we've previously spotted, so add it to the dictionary:

\begin{minted}{php}
    9 => "IX",
\end{minted}

\textbf{Run your tests}. \textbf{Green}.
\\

Now for ten:

\begin{minted}{php}
    public function test10()
    {
        $this->assertSame("X", $this->rn->forNumber(10));
    }
\end{minted}

\textbf{Run your tests}. \textbf{Red} as a red thing.
\\

Again, this doesn't fit any pattern we've previously spotted, so add it to the dictionary:

\begin{minted}{php}
    10 => "X",
\end{minted}

\textbf{Run your tests}. Purest \textbf{green}.
\\

Guess what? Time for eleven:

\begin{minted}{php}
    public function test11()
    {
        $this->assertSame("XI", $this->rn->forNumber(11));
    }
\end{minted}

\textbf{Run your tests}. Our first free \textbf{green}!
\\

And if you wrote tests for \texttt{12} (\texttt{"XII"}) through to \texttt{19} (\texttt{"XIX"}) you'd find they would all be green too.
\\

But our luck runs out at 20:

\begin{minted}{php}
    public function test20()
    {
        $this->assertSame("XX", $this->rn->forNumber(20));
    }
\end{minted}

\textbf{Run your tests}. Back to \textbf{red}.
\\

For now, let's just add it to the dictionary:

\begin{minted}{php}
    20 => "XX",
\end{minted}

\textbf{Run your tests}. \textbf{Green}zo.
\\

And let's try 30:

\begin{minted}{php}
    public function test30()
    {
        $this->assertSame("XXX", $this->rn->forNumber(30));
    }
\end{minted}

\textbf{Run your tests}. \textbf{Red} as a radish.
\\

Again, let's just add it to the dictionary:

\begin{minted}{php}
    30 => "XXX",
\end{minted}

\textbf{Run your tests}. \textbf{Green}. But, again, we can see a pattern here: we've just got an extra \texttt{X} per \texttt{10}. Let's refactor:

\begin{minted}{php}
    public function forNumber(int $number) : string
    {
        $result = "";

        foreach ($this->dictionary as $value => $numeral) {
            // change the if to a while
            // will repeat on a number until it
            // gets lower than it
            while ($number >= $value) {
                $result .= $numeral;
                $number -= $value;
            }
        }

        return $result . str_repeat("I", $number);
    }
\end{minted}

\textbf{Run your tests}. Still \textbf{green}!
\\

And we can actually refactor again. The repeated \texttt{I} can be dealt with by adding it to our dictionary:

\begin{minted}{php}
    private $dictionary = [
        // ... other values
        1 => "I",
    ];

    public function forNumber(int $number) : string
    {
        $result = "";

        foreach ($this->dictionary as $value => $numeral) {
            while ($number >= $value) {
                $result .= $numeral;
                $number -= $value;
            }
        }

        // just return result
        return $result;
    }
\end{minted}

\textbf{Run your tests}. Stiller \textbf{green}! A double refactoring. No special cases for \texttt{I} anymore.
\\

We're still not done, but the rest is pretty trivial as we've worked out the main pattern. Try adding tests for the following and getting it to work:

\begin{itemize}
    \item 40 = XL
    \item 50 = L
    \item 90 = XC
    \item 100 = C
    \item 400 = CD
    \item 500 = D
    \item 900 = CM
    \item 1,000 = M
    \item 3,994 = MMMCMXCIV
\end{itemize}

Now pick a number between 1,000 and 10,000 and check if it works for that too!
\\

You can see the final versions of \href{https://github.com/develop-me/bootcamp--laravel-project/blob/develop/app/RomanNumeral.php}{\texttt{RomanNumeral}} and \href{https://github.com/develop-me/bootcamp--laravel-project/blob/develop/tests/Unit/RomanNumeralTest.php}{\texttt{RomanNumeralTest}} on GitHub.


\section{Git Hooks}

Now that we're test-driven, we should be careful to never commit any code to Git \textit{if} any of our tests are failing.
\\

We can use \textbf{Git Hooks} to guarantee that we can't commit failing code. Hooks are custom bits of code that run at specific points in the Git life-cycle.
\\

We're interested in the \texttt{pre-commit} hook. If this bit of code returns an \textbf{error code} (any number except \texttt{0}) then Git won't allow the commit to run.
\\

When all of your PHPUnit tests succeed you get back a \texttt{0} exit code, but if any fail you'll get back a non-zero exit code. That means all we need to put in our hook is code that runs PHPUnit.
\\

Hooks live in the \texttt{.git/hooks} directory inside your project. So we need to create a file called \texttt{.git/hooks/pre-commit} and then put the following inside:

\begin{minted}{bash}
    #!/bin/bash

    vendor/bin/phpunit --testsuite Unit
\end{minted}

This is just the command that we've been running manually.
\\

We also need to give this file execution permissions, otherwise it can't be run:

\begin{minted}{bash}
    chmod +x .git/hooks/pre-commit
\end{minted}

Now, whenever you try to commit anything to Git the tests will run and if any of them fail the commit will fail. As long as you've used TDD, it's now not possible to commit broken code.

% git bisect?

\section{Additional Resources}

\begin{itemize}[leftmargin=*]
    \item \href{https://www.freecodecamp.org/news/test-driven-development-what-it-is-and-what-it-is-not-41fa6bca02a2/}{What is Test Driven Development?}
    \item \href{https://www.codecademy.com/articles/tdd-red-green-refactor}{Red, Green, Refactor}
    \item \href{https://www.sandimetz.com/99bottles}{99 Bottles of OOP}
    \item \href{https://git-scm.com/book/en/v2/Customizing-Git-Git-Hooks}{Git Hooks}
\end{itemize}
