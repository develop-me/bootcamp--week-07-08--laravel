\textbf{Unit Testing} is when we test small parts of our code to check that it works as we expect. This can save us having to dump bits of code to see what's going on.
\\

Because unit tests are bits of code, we can run them as often as we like. This is much more efficient than manually testing/re-testing your code.
\\

Laravel makes it very easy to unit test code. All our unit tests live in the \texttt{tests/Unit} directory. You can see an example test called \texttt{ExampleTest.php} already in there.

\section{Running Tests}

To run all of your unit tests run the following:

\begin{minted}{bash}
    vendor/bin/phpunit --filter Unit
\end{minted}

You should get a message saying:

\begin{minted}{text}
    OK (1 test, 1 assertion)
\end{minted}

If you don't include the \texttt{--filter Unit} bit, it will also run \textbf{Feature Tests}, which let you test broader functionality, but we're not interested in this at the moment.
\\

You can now delete the \texttt{tests/Unit/ExampleTest.php} file, as we'll create our own tests next.


\section{Generating Tests}

Laravel can automatically generate unit tests for us:

\begin{minted}{bash}
    artisan make:test ArticleTest --unit
\end{minted}

There should now be a file called \texttt{ArticleTest} in the unit tests directory.


\section{Writing Tests}

Let's have a look at the test class:

\begin{minted}{php}
    namespace Tests\Unit;

    use Illuminate\Foundation\Testing\RefreshDatabase;
    use Tests\TestCase;

    class ArticleTest extends TestCase
    {
        public function testExample()
        {
            $this->assertTrue(true);
        }
    }
\end{minted}

Test class names need to \textit{end} with \texttt{Test} and to extend \texttt{TestCase} â€“ this is a class provided by Laravel that does most of the heavy-lifting for us. Under-the-hood, that class is itself extending a class provided by PHPUnit, the de facto PHP testing library.
\\

Test methods need to \textit{start} with \texttt{test}. You can do whatever you need to inside a test method, but importantly you should always \textbf{assert} something.

\subsection{Asserting}

``Asserting'' something just means saying ``This should be the case''. So if we assert that something is true, we're saying ``This value should be true''. An assertion can be correct, in which case the test passes, or incorrect, in which case the test fails.
\\

There's a \href{https://phpunit.readthedocs.io/en/9.0/assertions.html}{huge number of possible assertions}, but for now we'll stick to some basics:

\begin{itemize}
    \item \texttt{assertTrue}: assert that something is \texttt{true}
    \item \texttt{assertSame}: assert that two things are the same type and value
\end{itemize}

Technically speaking you only really need \texttt{assertTrue}, but the other methods provide useful shorthands.
\\

Let's write some assertions about an \texttt{Article}:

\begin{minted}{php}
    public function testFillable()
    {
        $article = new Article([
            "title" => "Hello",
            "content" => "Blah blah blah",
        ]);

        // title should be set, as it's in $fillable
        $this->assertTrue($article->title === "Hello");
    }
\end{minted}

We create a new \texttt{Article} and then assert it's true that it's \texttt{title} property is equal to \texttt{"Hello"}.
\\

We could of course write this using \texttt{assertSame}:

\begin{minted}{php}
    $this->assertSame("Hello", $article->title);
\end{minted}

Using \texttt{assertSame} is better, as if the test fails PHPUnit will tell you what it was expecting to happen. Notice that we put the \textbf{expected} value first and the \textbf{actual} value second, if it's the other way round the PHPUnit output will be backwards.
\\

Make sure to re-run your tests every time you make any changes:

\begin{minted}{bash}
    vendor/bin/phpunit --filter Unit
\end{minted}

We should also test that values not in \texttt{\$fillable} are not added:

\begin{minted}{php}
    public function testFillable()
    {
        $article = new Article([
            "title" => "Hello",
            "content" => "Blah blah blah",
            "danger" => "Aaaargh!",
        ]);

        // title should be set, as it's in $fillable
        $this->assertSame("Hello", $article->title);

        // danger shouldn't be set, as it's not in $fillable
        $this->assertSame(null, $article->danger);
    }
\end{minted}

Let's add a \texttt{truncate} method to our \texttt{Article} model:

\begin{minted}{php}
    use Illuminate\Support\Str;
\end{minted}

\begin{minted}{php}
    public function truncate()
    {
        // use the Laravel Str::limit method
        return Str::limit($this->content, 20);
    }
\end{minted}

We use Laravel's \href{http://laravel.com/docs/6.x/helpers#method-str-limit}{\texttt{Str::limit} helper method} to take the article content and limit it to 20 characters.
\\

We can now test this by adding the following to \texttt{ArticleTest}:

\begin{minted}{php}
    public function testTruncate()
    {
        $article = new Article([
            "title" => "Hello",
            "content" => "Blah blah blah",
        ]);

        // doesn't need truncating
        $this->assertSame("Blah blah blah", $article->truncate());

        $article = new Article([
            "title" => "Hello",
            "content" => "Blah blah blah blah blah blah blah",
        ]);

        // should be truncated
        $this->assertSame("Blah blah blah blah...", $article->truncate());
    }
\end{minted}


\subsection{Using the Constructor}

You'll notice that we use the same \texttt{Article} object in both tests, we could set this up in the \texttt{\_\_construct} method to save creating it twice:

\begin{minted}{php}
    private $article;

    public function __construct()
    {
        // make sure we call the parent's constructor
        parent::__construct();

        // setup the article
        $this->article = new Article([
            "title" => "Hello",
            "content" => "Blah blah blah",
        ]);

    }

    public function testTitle()
    {
        // use the article *property*
        $this->assertSame("Hello", $this->article->title);
    }

    public function testTruncate()
    {
        // use the article *property*
        $this->assertSame("Blah blah blah", $this->article->truncate());

        // ...rest of test
    }
\end{minted}


\section{Testing with a Database}

Sometimes we need to test things that involve the database. However, we don't want to pollute our normal database with test data. If we run the same test hundreds of times, we don't want to end up with the same test article hundreds of times. It's also harder to write tests if we don't know the state of the database before we start.
\\

For this reason we usually use a \textit{separate} database for testing. We're going to use an \textbf{in-memory SQLite} database. You don't really need to worry about what that means as Laravel does all the work for us, but basically it's temporary and stored in memory (as opposed to on the hard-drive), so it's really fast.


\pagebreak


\subsection{Setting Up a Test Database}

First, we'll need to add the following to the \texttt{connections} section of \\ \texttt{config/database.php}:

\begin{minted}{php}
    'testing' => [
        'driver'   => 'sqlite',
        'database' => ':memory:',
        'prefix'   => '',
    ],
\end{minted}

Then we need to tell PHPUnit to use that database instead of the normal one. We do this by adding a line to the \texttt{<php>} section of the \texttt{phpunit.xml} file:

\begin{minted}{xml}
    <php>
        // ... other <server /> tags
        <server name="DB_CONNECTION" value="testing"/>
    </php>
\end{minted}


\subsection{Using the Test Database in Tests}

We need to make a few changes to our test before we can work with the database.
\\

First, we need to extend the \textit{Laravel} \texttt{TestCase} class. Replace the \\ \texttt{use PHPUnit\textbackslash{}Framework\textbackslash{}TestCase} line with:

\begin{minted}{php}
    use Tests\TestCase;
\end{minted}

We can also tell Laravel to automatically refresh (clear and then migrate) the database for each test we run. This makes the database state more predictable.
\\

Add the following \texttt{use} statement:

\begin{minted}{php}
    use Illuminate\Foundation\Testing\DatabaseMigrations;
\end{minted}

Then, as the very first line in your class add the following:

\begin{minted}{php}
    class ArticleTest extends TestCase
    {
        use DatabaseMigrations;

        // ...rest of class code
    }
\end{minted}

This is called a \texttt{trait}: it effectively adds a method to your class.
\\

Now we can write tests involving the database.


\subsection{Writing Database Tests}

Now we can now write code that uses the database just as we normally would:

\begin{minted}{php}
    public function testDatabase()
    {
        // add an article to the database
        Article::create([
            "title" => "Hello",
            "content" => "Blah blah blah",
        ]);

        // get the first article back from the database
        $articleFromDB = Article::all()->first();

        // check the titles match
        $this->assertSame("Hello", $articleFromDB->title);
    }
\end{minted}

Because the database is wiped before each test, we can be sure that the first article in the database is the one we just added.
\\

The test above isn't particularly useful, but when it comes to testing our controllers it can be.


\pagebreak


\section{Testing Controllers}

First, let's create a new test, putting it in an appropriate namespace:

\begin{minted}{bash}
    artisan make:test Http\\Controllers\\API\\ArticlesTest --unit
\end{minted}

Then we'll edit the test file:

\begin{minted}{php}
    namespace Tests\Unit\Http\Controllers\API;

    // setup to use database
    use Illuminate\Foundation\Testing\DatabaseMigrations;
    use Tests\TestCase;

    // use classes we'll need
    use App\Article;

    class ArticlesTest extends TestCase
    {
        // the database migrations trait
        // ensures the database is cleared between tests
        use DatabaseMigrations;

        // a test for the controller's store() method
        public function testStore()
        {
            // use the "call" method to fake a
            // POST request to /api/articles
            // then get the original content (otherwise we'll get JSON)
            $response = $this->call('POST', '/api/articles', [
                "title" => "foo",
                "content" => "bar",
            ])->getOriginalContent();

            // check we get the article back
            $this->assertSame("bar", $response->content);

            // test to see if it's been added to the database
            $article = Article::all()->first();
            $this->assertSame("bar", $article->content);
        }
    }
\end{minted}

First, we do the usual database test setup bits and pieces. Then in our test we make a fake \texttt{POST} call to \texttt{api/articles} and get the ``original content'' (this gives us back what was actually returned, rather than the JSON version). Then we test first to see if we got an article with the right \texttt{content} back and secondly to see if it was added to the database.
\\

As always, don't forget to run your tests:

\begin{minted}{bash}
    vendor/bin/phpunit --filter Unit
\end{minted}

If all tests pass we can be sure that the \texttt{store} method is doing what we expect: taking the data from the request, storing it in the database, and returning it.



\section{Additional Resources}

\begin{itemize}[leftmargin=*]
    \item \href{https://github.com/sebastianbergmann/phpunit}{PHPUnit}
    \item \href{http://laravel.com/docs/6.x/testing}{Laravel: Testing - Getting Started}
\end{itemize}
