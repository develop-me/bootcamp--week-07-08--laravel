If we want to submit data to the site we'll need a form.
\\

Let's create a simple form for creating a new blog post.
\\

In \texttt{resources/views/form.blade.php}:

\inputminted{php}{09-forms/figures/01-form.blade.php}

And add a route so that we can view it:

\begin{minted}{php}
    Route::group(["prefix" => "articles"], function () {
        // add *above* route with URL parameter
        // otherwise 'create' will get included in that
        Route::get('create', "Articles@create");
        Route::get('{article}', "Articles@show");
    });
\end{minted}

Then in your \texttt{Articles} controller:

\begin{minted}{php}
    public function create()
    {
        return view("form");
    }
\end{minted}

Now visit \texttt{/articles/create} and you should see the form we just created.

\section{Form \texttt{method}}

If you add some data and then try to submit the form you'll notice that the page refreshes and the URL now includes a lot of extra gumpf after a \texttt{?} character.

\begin{minted}[fontsize=\footnotesize]{text}
    /articles/create?title=Tea&content=These%20teas%20are%20the%20bees%20knees
\end{minted}

This is known as a \texttt{query string} and you'll see that it contains the data that you've just submitted.
\\

When data is submitted in this way we call it a \texttt{GET} request: the data is submitted as part of the URL. This is very useful for things like search forms, where each search query creates a different URL. However, it's no good for submitting lots of data as URLs have a limited length. It's also no good for submitting sensitive data, as all of the data in the URL gets added to your browser history, which has various security implications.
\\

That's where \texttt{POST} comes in. If we tell a browser to submit a form using \texttt{POST} it will submit the data as the \textbf{body} of the request. We'll look at exactly what this means later in the course, but for now all you need to know is that that data gets sent to the server, but it doesn't get added to the URL.

\begin{tabu}{l l l X}
    \textbf{Method} & \textbf{How it submits data}       & \textbf{Example usage} \\
    \texttt{GET}    & Data is added to the URL           & A search form \\
    \texttt{POST}   & Data in the body of the request    & Submitting complex/sensitive data \\
\end{tabu}

\par\bigskip

By default a \texttt{<form>} will submit data as a \texttt{GET} request. To get it to use \texttt{POST} we'll need to add the \texttt{method} attribute to our template:

\begin{minted}{html}
    <form class="form" method="post">
\end{minted}


\begin{infobox}{\texttt{action}}
    When we submit data to a form we need to tell it where to submit the data to. In a Laravel app it is normal to submit data to the same URL as the page, we can do this because rendering the page is a \texttt{GET} request, whereas submitting the form is usually a \texttt{POST} request. We do not need to specify an \texttt{action} attribute in this case.
\end{infobox}


\section{\texttt{GET} Requests}

Useful for search. Never use for submitting things like passwords.

\section{\texttt{POST} Requests}

\texttt{POST} routes should \textbf{always} return a call to \texttt{redirect()}. This avoids resubmitting the form if the page is refreshed.

\subsection{Mass Assignment Vulnerability}

By default Laravel won't let you do things that might cause security problems. Accepting whatever the user gives you and sending it straight to the database is one of those cases: known as the \textbf{mass assignment vulnerability}.
\\

Imagine you have a \texttt{users} table that has an \texttt{admin} column for keeping track of whether a user is an admin or not. This is pretty common, so a hacker might try to exploit it. Your user sign-up form probably doesn't have an \texttt{admin} option, but a hacker can easily make a sign-up API request directly (with Postman or \texttt{curl}). They add an \texttt{"admin": true} property to the JSON that they send. Now, if your controller just takes \textit{everything} that they sent and tries to update the database, the hacker has just been given admin rights.
\\

To stop this from happening, if you pass an Eloquent model and array of properties to update, it will only update the properties that you've listed in the model's \texttt{\$fillable} property. If you've not set this property and try to pass in an array of values you'll get a 500 error.
\\

We need to update the \texttt{Article} model to tell it which fields to expect:

\begin{minted}{php}
    class Article extends Model
    {
        protected $fillable = ["content", "title"];

        // ... other Article code
    }
\end{minted}

\section{Cross-Site Request Forgery}

Make sure you include a CSRF token on any forms:

\begin{minted}{php}
    @csrf
\end{minted}

\section{Sanitising Data}

We need to be careful with the data that the user submits.

\subsection{MySQL Injection}


\section{Validation}
You should always validate any data that gets submitted to your site on the server-side. For a good user-experience you should probably also have validation on the client-side using JavaScript, but it's perfectly possible that a user might have JavaScript disabled or that a malicious party might be making a direct request.
\\

The idea of validation is to turn a certain class of \texttt{500} errors into \texttt{4xx} errors. Remember, client-side code can't do anything useful with \texttt{500} errors, but \texttt{4xx} errors have specific meanings.
\\

To avoid any MySQL errors we need to at minimum validate the following:

\begin{itemize}
    \item \texttt{required}: any database fields that cannot be \texttt{null} should have the \texttt{required} validation
    \item \texttt{max:255}: if you're storing data in a \texttt{VARCHAR} then make sure you have max length validation that matches the \texttt{VARCHAR} length
    \item \texttt{date}/\texttt{integer}/\texttt{string}: check formats before inserting into MySQL. These are not the database migration types, but validation specific rules - so \texttt{VARCHAR} and \texttt{TEXT} both count as \texttt{string} for validation. You will also need the \texttt{nullable} validation if the field is not required.
\end{itemize}

As well as the cases above there are plenty of \href{http://laravel.com/docs/master/validation#available-validation-rules}{other bits of validation} that you can do easily with Laravel.
\\

As with everything in Laravel, we'll need to create a new type of class. In this case it's a \texttt{FormRequest} class. The \texttt{FormRequest} class actually inherits everything from the \texttt{Request} class that we're already using in our controller when we want to work with the request the user made.
\\

Use \texttt{artisan} to create a \texttt{FormRequest} class:

\begin{minted}{bash}
    artisan make:request ArticleRequest
\end{minted}

This will create a file in \texttt{app/Http/Requests}. The \texttt{ArticleRequest} class has two methods. We first need to return \texttt{true} from the \texttt{authorize} method: this method can be very useful when you support user logins in your API, but for now we'll just assume everyone can make requests. The \texttt{rules} method needs to return an associative array, where the property name is the JSON property that needs validating and its value is an array of validation rules:

\phpinputminted{09-forms/figures/01-validation}


Finally we need to  update the \texttt{Articles} controller to use our validated request instead of the standard \texttt{Request} object. First let it know where the \texttt{ArticleRequest} class lives:

\begin{minted}{php}
    use App\Http\Requests\ArticleRequest;
\end{minted}

And then update the type-hinting on the \texttt{store} and \texttt{update} methods to use the \texttt{ArticleRequest} class instead of \texttt{Request}:

\phpinputminted{09-forms/figures/02-type-hint}

This works because \texttt{ArticleRequest} is a descendant of \texttt{Request}, so it has all of the same methods and properties.


% - use old() to get previously submitted values
