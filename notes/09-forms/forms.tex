If we want to submit data to the site we'll need a form.

\section{The \texttt{method} Attribute}

\section{\texttt{GET} Requests}

Useful for search. Never use for submitting things like passwords.

\section{\texttt{POST} Requests}

\texttt{POST} routes should \textbf{always} return a call to \texttt{redirect()}. This avoids resubmitting the form if the page is refreshed.

\subsection{Mass Assignment Vulnerability}
By default Laravel won't let you do things that might cause security problems. Accepting whatever the user gives you and sending it straight to the database is one of those cases: known as the \textbf{mass assignment vulnerability}.
\\

Imagine you have a \texttt{users} table that has an \texttt{admin} column for keeping track of whether a user is an admin or not. This is pretty common, so a hacker might try to exploit it. Your user sign-up form probably doesn't have an \texttt{admin} option, but a hacker can easily make a sign-up API request directly (with Postman or \texttt{curl}). They add an \texttt{"admin": true} property to the JSON that they send. Now, if your controller just takes \textit{everything} that they sent and tries to update the database, the hacker has just been given admin rights.
\\

To stop this from happening, if you pass an Eloquent model and array of properties to update, it will only update the properties that you've listed in the model's \texttt{\$fillable} property. If you've not set this property and try to pass in an array of values you'll get a 500 error.
\\

We need to update the \texttt{Article} model to tell it which fields to expect:

\begin{minted}{php}
    class Article extends Model
    {
        protected $fillable = ["content", "title"];

        // ... other Article code
    }
\end{minted}

\section{Cross-Site Request Forgery}

Make sure you include a CSRF token on any forms:

\begin{minted}{php}
    @csrf
\end{minted}

\section{Sanitising Data}

We need to be careful with the data that the user submits.

\subsection{MySQL Injection}


\section{Validation}
You should always validate any data that gets submitted to your site on the server-side. For a good user-experience you should probably also have validation on the client-side using JavaScript, but it's perfectly possible that a user might have JavaScript disabled or that a malicious party might be making a direct request.
\\

The idea of validation is to turn a certain class of \texttt{500} errors into \texttt{4xx} errors. Remember, client-side code can't do anything useful with \texttt{500} errors, but \texttt{4xx} errors have specific meanings.
\\

To avoid any MySQL errors we need to at minimum validate the following:

\begin{itemize}
    \item \texttt{required}: any database fields that cannot be \texttt{null} should have the \texttt{required} validation
    \item \texttt{max:255}: if you're storing data in a \texttt{VARCHAR} then make sure you have max length validation that matches the \texttt{VARCHAR} length
    \item \texttt{date}/\texttt{integer}/\texttt{string}: check formats before inserting into MySQL. These are not the database migration types, but validation specific rules - so \texttt{VARCHAR} and \texttt{TEXT} both count as \texttt{string} for validation. You will also need the \texttt{nullable} validation if the field is not required.
\end{itemize}

As well as the cases above there are plenty of \href{http://laravel.com/docs/master/validation#available-validation-rules}{other bits of validation} that you can do easily with Laravel.
\\

As with everything in Laravel, we'll need to create a new type of class. In this case it's a \texttt{FormRequest} class. The \texttt{FormRequest} class actually inherits everything from the \texttt{Request} class that we're already using in our controller when we want to work with the request the user made.
\\

Use \texttt{artisan} to create a \texttt{FormRequest} class:

\begin{minted}{bash}
    artisan make:request ArticleRequest
\end{minted}

This will create a file in \texttt{app/Http/Requests}. The \texttt{ArticleRequest} class has two methods. We first need to return \texttt{true} from the \texttt{authorize} method: this method can be very useful when you support user logins in your API, but for now we'll just assume everyone can make requests. The \texttt{rules} method needs to return an associative array, where the property name is the JSON property that needs validating and its value is an array of validation rules:

\phpinputminted{09-forms/figures/01-validation}


Finally we need to  update the \texttt{Articles} controller to use our validated request instead of the standard \texttt{Request} object. First let it know where the \texttt{ArticleRequest} class lives:

\begin{minted}{php}
    use App\Http\Requests\ArticleRequest;
\end{minted}

And then update the type-hinting on the \texttt{store} and \texttt{update} methods to use the \texttt{ArticleRequest} class instead of \texttt{Request}:

\phpinputminted{09-forms/figures/02-type-hint}

This works because \texttt{ArticleRequest} is a descendant of \texttt{Request}, so it has all of the same methods and properties.


% - use old() to get previously submitted values
