Databases are pieces of software that store structured data for us.
\\

The most common form of database is the ``relational database''. To get data in and out of a relational database we use a ``Structured Query Language'' (SQL).
\\

SQL comes in many flavours: MySQL, MariaDB, PostgreSQL, SQL Server, SQLite. We'll be using MySQL.


\begin{infobox}{NoSQL}
    % Needs de-ranting

    \quoteinline{It’s a curious thing about our industry: not only do we not learn from our mistakes, we also don’t learn from our successes}{Keith Braithwaite}

    It's become very trendy to use NoSQL databases to make API driven apps. The most popular being MongoDB.
    \\

    MongoDB is a ``document'' database: it's designed for storing arbitrary data, as opposed to specific data types. If that's all you use it for then it's really efficient - although such features are now common in SQL databases like PostgreSQL. But people got carried away and tried to use it to store \textit{relational} data and ended up getting themselves into lots of issues - do a search for ``MongoDB to PostgreSQL'' for many an article on the subject.
    \\

    It turns out that \textit{most} data you'll ever want to store and work with is relational, so you should probably stick to a relational database most the time.
    \\

    That's not to say that NoSQL has no place in the world: it's really good for specific uses cases and more often than not should be used \textit{alongside} SQL databases.
    \\

    For example it's very common to pair up ElasticSearch with an SQL database: searching an SQL database for key terms is either very inefficient or involves a lot of extra tables and code. ElasticSearch does it all for us with very little effort. However, you'd still want to store your main data in an SQL database.
    \\

    Another case is using a graph database (such as Neo4j) alongside SQL. Although SQL is good at storing specific relationships, it's very bad at exploring those relationships: for example, Facebook finding all of your friends' friends. In fact the relationships don't need to get very complicated before it would take SQL millennia to find every possible relationship. Graph databases are designed specifically to find relationships and can do this very quickly. Again, you'd probably want to store your main data in an SQL database
\end{infobox}


\section{Database Structure}

It's easiest to think of the structure of databases with an example. Let's say that we're going to create a blog which consists of lost of articles. Each article has a title and a body (the text of the article) as well as a creation date.
\\

We would have a single database
\\

An SQL database is made up of \textbf{tables}, which are in turn made up of \textbf{rows}, which have one or more \textbf{columns}.
\\

A table represents a collection of some \textit{thing}, say blog articles. A row is a single instance of that thing, an article. And a column represents a specific piece of information about that thing, say a title.
\\

\begin{small}
    \begin{tabu}{l l X}
        \texttt{id} & \texttt{title}            & \texttt{body} \\
        1           & Where Do Eels Come From?  & Nobody knows exactly  \\
        2           & Do Moose Get Drunk?       & Maybe \\
    \end{tabu}
\end{small}
\par\bigskip

Generally we'd probably have one database per website.


\section{Column Types}

Each column stores a specific type of data. Here are a few of the most common types (although there are many more):
\\

\begin{small}
    \begin{tabu}{l l X}
        \texttt{Type}       & \texttt{Purpose}       & \texttt{Notes} \\
        \texttt{VARCHAR}    & Short pieces of text   & Fixed length  \\
        \texttt{TEXT}       & Long pieces of text    & Flexible length, with performance hit  \\
        \texttt{INT}        & Whole numbers          & Signed (\texttt{+}/\texttt{-}) and unsigned  \\
        \texttt{TINYINT}    & Small whole numbers    & Often used to store boolean values (\texttt{0} and \texttt{1})  \\
        \texttt{DECIMAL}    & Decimal point numbers  & Need to specify a precision \\
        \texttt{DATE}       & Dates                  &  \\
        \texttt{DATETIME}   & Storing times          & If you don't need to support time-zones \\
        \texttt{TIMESTAMP}  & Storing accurate times & If you do need to support time-zones \\
    \end{tabu}
\end{small}
\par\bigskip


\section{IDs}

A row in an SQL database always has to have one ``unique'' way of identifying it - otherwise there's no way to select/update a single row. For our purposes we'll just use a numeric ID. MySQL can automatically generate these for us.
\\

\begin{infobox}{Beyond IDs}
    More complex systems (particularly ones spread across multiple servers) might need to use a more complex system such as ``UUID''s (\href{https://en.wikipedia.org/wiki/Universally\_unique\_identifier}{Universally Unique Identifiers}).
    \\

    The unique aspect can also be a combination of multiple columns. This can be very useful with complex relationships.
\end{infobox}



\section{SQL}

\subsection{\texttt{CREATE DATABASE}}

We can use \texttt{CREATE DATABASE} to add a new database.

\begin{minted}{mysql}
    CREATE DATABASE database_name;
\end{minted}


\subsection{\texttt{USE}}

Once we've created a database we need to tell MySQL that we want to work with that database:

\begin{minted}{mysql}
    USE database_name;
\end{minted}

\textbf{You won't be able to run any of the other commands unless you have told MySQL which database you need to use.}

\subsection{\texttt{CREATE TABLE}}

This is probably the most complex of the commands as we need to define our table structure. Line breaks can make this easier to follow. Until you have a semi-colon at the end of the line MySQL won't try to interpret what you've written.

\begin{minted}{mysql}
    CREATE TABLE articles (
        # add an auto-incrementing ID
        id INT NOT NULL PRIMARY KEY AUTO_INCREMENT,
        # add a title with max length of 100
        title VARCHAR(100),
        # add a body that can be as long as you like
        body TEXT,
        # add a created_at column that gets set automatically
        created_at DEFAULT CURRENT_TIMESTAMP,
        # add an updated_at column that gets updated automatically
        updated_at DEFAULT CURRENT_TIMESTAMP ON UPDATE CURRENT_TIMESTAMP
    );
\end{minted}

\subsection{\texttt{SELECT}}

We can use \texttt{SELECT} to get information out of a specific table:

\begin{minted}{mysql}
    SELECT * FROM articles;
\end{minted}

If we're only interested in some of the columns we can specify this:

\begin{minted}{mysql}
    SELECT id, title, body FROM articles;
\end{minted}



\subsection{\texttt{UPDATE}}


\subsection{\texttt{ALTER}}


\subsection{\texttt{DELETE}}


\subsection{\texttt{DROP}}

We can use \texttt{DROP} to remove a table:\footnote{Use with caution!}

\begin{minted}{mysql}
    DROP TABLE table_name;
\end{minted}

We can also use \texttt{DROP} to remove an entire database:\footnote{Use with \textit{extreme} caution!}

\begin{minted}{mysql}
    DROP DATABASE database_name;
\end{minted}


\begin{infobox}{Joins}
    We've not actually covered the ``relational'' part of relational databases. We can use the \texttt{JOIN} command to get related data from multiple tables in a very efficient manner.
    \\

    We'll be covering the \textit{structure} of these relationships later in the course, but we won't actually be using MySQL queries.
\end{infobox}


\section{Additional Resources}

\begin{itemize}[leftmargin=*]
    \item \href{https://dev.mysql.com/doc/refman/5.7/en/data-types.html}{MySQL Data Types}
    \item \href{https://blog.codinghorror.com/a-visual-explanation-of-sql-joins/}{A Visual Explanation of SQL Joins}
\end{itemize}
