\section{Controllers}

\textbf{Controller} is another term that comes up a lot in software development. A controller's job is to bring together all the other bits of code that make up an app: to \textit{control} what happens. In Laravel, controllers are called by the router: they take the request, do whatever it is that needs doing, and then return a response.
\\

Run the following inside your Vagrant box to create an Articles controller:

\begin{minted}{bash}
    artisan make:controller Articles
\end{minted}

This will create a file (\texttt{app/Http/Controllers/Articles.php}), which contains the boilerplate for a controller.
\\

\subsection{Controller Methods}

You can define your own methods in your controller for handling different requests.
\\

This \texttt{show()} method is designed to find and show a single article, invoking the \texttt{articles/show.blade.php} template to do so.
\\

The data (properties) from the Article model are passed into the view with the variable name \texttt{article}.

\begin{minted}{php}
    class Articles extends Controller
    {
        // shows single article
        public function show($id)
        {
            $article = Article::find($id);

            return view("articles/show", [
                "article" => $article
            ]);
        }
    }
\end{minted}

Invoking this controller to handle a request would be done on the route, as such:

\begin{minted}{php}
    Route::get('articles/{id}', "Articles@show");
\end{minted}

\subsection{Route Model Binding}

Laravel is able to resolve Eloquent models defined in routes or controller actions where the type-hinted variable name (\texttt{\$article} below) matches the route segment name (\texttt{\{article\}} below). For example:

\begin{minted}{php}
    Route::get('articles/{article}', function (App\Article $article) {
        return $article->title;
    });
\end{minted}

Since the \texttt{\$article} variable is type-hinted as the \texttt{App\\Article} Eloquent model and the variable name matches the \texttt{\{article\}} URI segment, Laravel will automatically inject the model instance that has an ID matching the corresponding value from the request URI.
\\

This can simplify the above \texttt{show()} method to:

\begin{minted}{php}
    class Articles extends Controller
    {
        // shows single article
        public function show(Article $article)
        {
            return view("articles/show", [
                "article" => $article
            ]);
        }
    }
\end{minted}

And route to:

\begin{minted}{php}
    Route::get('articles/{article}', "Articles@show");
\end{minted}

\begin{infobox}{View All Routes}
    A useful command to see all routes setup, the HTTP methods for them, which controllers and which methods will be run:

    \begin{minted}{bash}
        artisan route:list
    \end{minted}

\end{infobox}

\section{Additional Resources}

\begin{itemize}[leftmargin=*]
    \item \href{https://laravel.com/docs/master/routing}{Routing}
    \item \href{http://laravel.com/docs/master/controllers}{Controllers}
    \item \href{https://laraveldaily.com/how-to-structure-routes-in-large-laravel-projects/}{How to Structure Routes in Large Laravel Apps}
\end{itemize}
